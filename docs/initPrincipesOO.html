<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Sensibilisation aux principes fondamentaux en conception et programmation objet et design pattern</title><meta name="generator" content="DocBook XSL Stylesheets V1.65.1"><meta name="description" content="Ce document a &eacute;t&eacute; r&eacute;alis&eacute; sous GNU/Linux avec vim, au format  docbook , mis en page avec le processeur XSLT  saxon d&eacute;velopp&eacute; par Michael Kay et les feuilles de styles de  Norman Walsh."></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="article" lang="fr"><div class="titlepage"><div><div><h1 class="title"><a name="index"></a>Sensibilisation aux principes fondamentaux en conception et programmation objet et design pattern</h1></div><div><div class="author"><h3 class="author"><span class="firstname">Olivier</span> <span class="surname">Capuozzo</span></h3></div></div><div><p class="pubdate">07 mars 2004</p></div><div><div class="revhistory"><table border="1" width="100%" summary="Revision history"><tr><th align="left" valign="top" colspan="3"><b>Historique des versions</b></th></tr>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tr><td align="left">Version 0.1</td><td align="left">29 Ao&ugrave;t 2004</td><td align="left">kpu</td></tr><tr><td align="left" colspan="3">Nouveau chapitre : Rappel concepts objet et UML</td></tr>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tr><td align="left">Version 0.2</td><td align="left">06 F&eacute;vrier 2004</td><td align="left">kpu</td></tr><tr><td align="left" colspan="3">Retouche de la note Java et h&eacute;ritage</td></tr>


&nbsp;&nbsp; </table></div></div><div><div class="abstract"><p class="title"><b>R&eacute;sum&eacute;</b></p><p>Ce document a &eacute;t&eacute; r&eacute;alis&eacute; sous GNU/Linux avec <a href="http://www.vim.org" target="_top">vim</a>, au format <a href="http://www.oasis-open.org/docbook/" target="_top"> docbook </a>, mis en page avec le processeur XSLT <a href="http://saxon.sourceforge.net" target="_top"> saxon</a> d&eacute;velopp&eacute; par Michael Kay et les feuilles de styles de  <a href="http://nwalsh.com/" target="_top">Norman Walsh</a>.</p></div></div></div><div></div><hr></div><div class="toc"><p><b>Table des mati&egrave;res</b></p><dl><dt><span class="sect1"><a href="#d0e62">1. Introduction &agrave; la notion de principes de conception objet</a></span></dt><dd><dl><dt><span class="sect2"><a href="#ref">1.1. R&eacute;f&eacute;rences</a></span></dt><dt><span class="sect2"><a href="#d0e114">1.2. Approche objet du logiciel</a></span></dt><dt><span class="sect2"><a href="#d0e164">1.3. Activit&eacute;s de programmation</a></span></dt><dt><span class="sect2"><a href="#d0e201">1.4. Logicel flexible</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e229">2. Rappels de quelques concepts objet et d'&eacute;l&eacute;ments de notation UML</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e232">2.1. Gestion des d&eacute;pendances</a></span></dt><dt><span class="sect2"><a href="#d0e250">2.2. Repr&eacute;sentation des relations avec UML</a></span></dt><dt><span class="sect2"><a href="#d0e281">2.3. Repr&eacute;sentation des associations et d&eacute;pendances entre classes</a></span></dt><dt><span class="sect2"><a href="#d0e312">2.4. Les 2 grandes fonctions de l'h&eacute;ritage</a></span></dt><dt><span class="sect2"><a href="#d0e394">2.5. Diff&eacute;rentes perspectives d'une vue</a></span></dt><dt><span class="sect2"><a href="#d0e443">2.6. Exercices</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e463">3. Quelques grands principes</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e466">3.1. Avertissement : YAGNI</a></span></dt><dt><span class="sect2"><a href="#d0e491">3.2. Principe d'Ouverture/Fermeture</a></span></dt><dt><span class="sect2"><a href="#d0e692">3.3. Principe de Substitution de Liskov</a></span></dt><dt><span class="sect2"><a href="#d0e747">3.4. Principe d'Inversion de Contr&ocirc;le</a></span></dt><dt><span class="sect2"><a href="#d0e863">3.5. Remarque</a></span></dt><dt><span class="sect2"><a href="#d0e872">3.6. Principe de s&eacute;paration des interfaces</a></span></dt><dt><span class="sect2"><a href="#d0e907">3.7. Principe de R&eacute;utilisation par Composition</a></span></dt><dt><span class="sect2"><a href="#d0e1013">3.8. Exercice</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e1075">4. Correction de l'exercice Table Ascii - OCP DIP</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e1141">4.1. Listing de la solution</a></span></dt><dt><span class="sect2"><a href="#d0e1149">4.2. Test</a></span></dt><dt><span class="sect2"><a href="#d0e1173">4.3. Conclusion</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e1190">5. Initiation au design pattern Factory</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e1193">5.1. Introduction</a></span></dt><dt><span class="sect2"><a href="#d0e1271">5.2. Factory (Fabrique)</a></span></dt><dt><span class="sect2"><a href="#d0e1318">5.3. Travaux pratiques</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e1357">6. Exemple de solution</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e1360">6.1. Introduction</a></span></dt><dt><span class="sect2"><a href="#d0e1378">6.2. Listing 1</a></span></dt><dt><span class="sect2"><a href="#d0e1395">6.3. Listing 3</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e1413">7. Conclusion</a></span></dt></dl></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e62"></a>1.&nbsp;Introduction &agrave; la notion de principes de conception objet</h2></div></div><div></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="ref"></a>1.1.&nbsp;R&eacute;f&eacute;rences</h3></div></div><div></div></div><div class="itemizedlist"><ul type="disc"><li><p>[Meyer] Conception et programmation orient&eacute;es objet . Bertrand Meyer. Ed. Eyrolles. Juin 2000</p></li><li><p>[Gof] Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides, Addison-Wesley 1999.</p></li><li><p>[<a href="http://objectmentor.com" target="_top">MARTIN00</a>] Design Principles and Design Patterns par Robert C. Martin.</p></li><li><p>[<a href="http://www.design-up.com" target="_top">Principes avanc&eacute;s de conception objet</a>] un dossier d'introduction, en Fran&ccedil;ais, sur ce th&egrave;me, par l'&eacute;quipe de <span class="foreignphrase"><i class="foreignphrase">Design-up</i></span>. A lire &agrave; la suite de cet article.</p></li><li><p>[Java Design] Buidling better apps &amp; applets par Peter Coad et Mark Mayfield ed. Prentice Hall PTR</p></li><li><p>[JOUP]  Objects, UML and Process par Kirk Knoernshild ed. Addison-Wesley, 2002.</p></li><li><p>[Larman] UML et les Design Patterns par Graig Larman, ed. CampusPress, 2002.</p></li><li><p>[Kent Beck] Extreme Programming la r&eacute;f&eacute;rence, ed. CampusPress, 2002.</p></li><li><p>[Robert C. Martin] UML for Java Programmers, ed. Prentice Hall, 2003.</p></li></ul></div><div class="itemizedlist"><p class="title"><b>Objectifs</b></p><ul type="disc"><li><p>Pr&eacute;senter les principaux principes en conception et programmation objet</p></li><li><p>Exemple de mise en oeuvre de ces principes et exercices</p></li></ul></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="d0e114"></a>1.2.&nbsp;Approche objet du logiciel</h3></div></div><div></div></div><p>"Un syst&egrave;me bien con&ccedil;u est facile &agrave; comprendre, facile &agrave; modifier et facile &agrave; r&eacute;utiliser" (in UML for Java programmers, R. C. Martin, ouvrage mentionn&eacute; ici <a href="#ref">R&eacute;f&eacute;rences</a>). </p><p>Les principales qualit&eacute;s vis&eacute;es par l'approche objet sont la Robustesse, Maintenabilit&eacute;, Extensibilit&eacute; et R&eacute;utilisabilit&eacute;.
  </p><div class="itemizedlist"><ul type="disc"><li><p><span class="emphasis"><em>Robustesse</em></span>: Pr&eacute;sence et respect de pr&eacute; et post conditions, conforme &agrave; l'esprit de la <span class="foreignphrase"><i class="foreignphrase">programmation par contrat</i></span> de B. Meyer. Gestion des exceptions.</p></li><li><p><span class="emphasis"><em>Maintenabilit&eacute;</em></span> : Respect de conventions d'&eacute;criture et pr&eacute;sence de tests unitaires.</p></li><li><p><span class="emphasis"><em>Extensibilit&eacute;</em></span> : Repr&eacute;sentation des parties stables par des classes concr&egrave;tes. Abstraction des parties extensibles.</p></li><li><p><span class="emphasis"><em>R&eacute;utilisabilit&eacute;</em></span> Gestion des d&eacute;pendances (interfaces, classes et paquetages) en vue d'une r&eacute;utilisation dans une autre application.</p></li></ul></div><p>A eux seuls, les concepts objets ne suffisent pas &agrave; produire des logiciels de qualit&eacute;.</p><p>La mise en oeuvre, et le maintien, de ces qualit&eacute;s est assur&eacute;e par le respect de cetains principes tout au long du cycle de vie du syst&egrave;me. </p><p>Bien entendu, on peut faire sans ; sans respecter les principes, sans respecter les mod&egrave;les de r&eacute;alisation de ces principes, cette "libert&eacute;" est repr&eacute;sent&eacute;e par la figure ci-dessous :</p><div class="figure"><a name="d0e153"></a><p class="title"><b>Figure&nbsp;1.&nbsp;Production de code et outils de conception </b></p><div><img src="schemaPDP.png" alt="Production de code et outils de conception"></div></div><p>Alors que les principes d&eacute;crivent QUOI faire, les <span class="foreignphrase"><i class="foreignphrase">designs patterns</i></span> (mod&egrave;les de conception) montrent COMMENT le faire, dans un contexte donn&eacute;. Quant aux frameworks (solution d'architecture applicative), ils d&eacute;montrent, &agrave; leur mani&egrave;re, comment impl&eacute;menter certains Designs Patterns. </p><p>Nous verrons quelques principes fondamentaux, et quelques exemples d'application.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="d0e164"></a>1.3.&nbsp;Activit&eacute;s de programmation</h3></div></div><div></div></div><p>Il est courant de partionner le travail du d&eacute;veloppeur en 3 activit&eacute;s : l'analyse, la conception et l'impl&eacute;mentation.</p><p>
En <span class="bold"><b>analyse</b></span>, l'accent est mis sur les <span class="emphasis"><em>responsabilt&eacute;s</em></span> des objets et leurs <span class="emphasis"><em>collaborations</em></span> en vue de r&eacute;pondre &agrave; des besoins exprim&eacute;s, par exemple sous la forme de <span class="emphasis"><em>cas d'utilisation</em></span>.</p><p>
En <span class="bold"><b>conception</b></span>, les responsabilit&eacute;s sont traduites en <span class="emphasis"><em>op&eacute;rations</em></span> (+ ou - typ&eacute;es). C'est ici que les d&eacute;cisions d'application de mod&egrave;les de conception (designs patterns), ou d'adoption de frameworks, sont le plus souvent prises (recherche d'une fl&eacute;xibilit&eacute;).
</p><p>Lors de l'activit&eacute; d'<span class="bold"><b>impl&eacute;mentation</b></span> les tests sont cod&eacute;s (approche <span class="emphasis"><em>test first</em></span>), les op&eacute;rations sont traduites en m&eacute;thodes avec, &eacute;ventuellement, une d&eacute;composition foctionnelle de ces derni&egrave;res (et introduction de m&eacute;thodes priv&eacute;es).
</p><p>Ces activit&eacute;s sont tr&egrave;s souvent enchev&eacute;tr&eacute;es : ainsi analyse t-on en impl&eacute;mentant des tests, le choix d'un pattern de conception s'impose parfois naturellement qu'apr&egrave;s une r&eacute;alisation. </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="d0e201"></a>1.4.&nbsp;Logicel flexible</h3></div></div><div></div></div><p>Il est connu qu'un logiciel commence &agrave; mourir le jour de sa livraison (lorsqu'il est termin&eacute;).</p><p><span class="emphasis"><em>lorsque les besoins commencent &agrave; changer, le syst&egrave;me commence &agrave; mourir, et sa survie est son challenge.</em></span> (Kirk Knoernshild, in "JOUP").</p><p>Un logiciel flexible est un logiciel qui accepte les changements sans (ou avec tr&egrave;s peu) de modifications de code.</p><p>Le pari s'av&egrave;re d'autant plus difficile que le changement fait partie de la nature m&ecirc;me des besoins.</p><p>Tout l'art est alors d'identifier les parties sujettes aux changements afin de les <span class="bold"><b>abstraire</b></span>, limitant ainsi les associations entre classes. Malheureusement cette pratique augmente la complexit&eacute; du syst&egrave;me.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="1" width="80%"><tr><td rowspan="2" align="center" valign="top" width="25"><img src="images/note.png"></td><td>Co&ucirc;t de la fl&eacute;xibilit&eacute;</td></tr><tr><td colspan="1" align="left" valign="top"><p><span class="emphasis"><em>Ce qui est flexible est complexe</em></span></p><p>Il toute fois pr&eacute;f&eacute;rable de limiter la compl&eacute;xit&eacute;. Il s'agit donc de concilier fl&eacute;xibilit&eacute; et simplicit&eacute; de conception.</p><p>La complexit&eacute; peut &ecirc;tre cach&eacute;e par l'adoption d'un framework, mais le syst&egrave;me devient alors d&eacute;pendant de celui-ci.</p></td></tr></table></div></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e229"></a>2.&nbsp;Rappels de quelques concepts objet et d'&eacute;l&eacute;ments de notation UML</h2></div></div><div></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="d0e232"></a>2.1.&nbsp;Gestion des d&eacute;pendances</h3></div></div><div></div></div><p>La recherche de la qualit&eacute; en programmation objet tient en quelques mots : <span class="emphasis"><em>Gestion des d&eacute;pendances</em></span> (d&eacute;pendance entre classes, d&eacute;pendances entre paquetages). L'objetif &eacute;tant de limiter les d&eacute;pendances entre parties imp&eacute;ment&eacute;es, pour une meilleure reutilisation, maintenance et flexibilit&eacute;. </p><p>Le code source ne nous permet pas de distinguer clairement les d&eacute;pendances entre des classes. Les clauses import donne des indications, mais sont parfois abusives.</p><p>Comment repr&eacute;senter ces d&eacute;pendances ? par un diagramme UML.</p><p>UML devenant ainsi un outil d'aide &agrave; la d&eacute;cision.</p><p>Un &eacute;l&eacute;ment A est d&eacute;pendant d'un &eacute;l&eacute;ment B lorsque la d&eacute;finition de A inclus celle de B.</p><p>Il y a d&eacute;pendance chaque fois qu'une relation existe entre des &eacute;l&eacute;ments.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="d0e250"></a>2.2.&nbsp;Repr&eacute;sentation des relations avec UML</h3></div></div><div></div></div><p>
UML d&eacute;finit quatre relations entre &eacute;l&eacute;ments : Association, G&eacute;n&eacute;ralisation, R&eacute;alisation et D&eacute;pendance.
  </p><div class="figure"><a name="d0e255"></a><p class="title"><b>Figure&nbsp;2.&nbsp;Association</b></p><div><img src="association.png" alt="Association"></div></div><div class="figure"><a name="d0e259"></a><p class="title"><b>Figure&nbsp;3.&nbsp;G&eacute;n&eacute;ralisation</b></p><div><img src="generalisation.png" alt="G&eacute;n&eacute;ralisation"></div></div><div class="figure"><a name="d0e263"></a><p class="title"><b>Figure&nbsp;4.&nbsp;R&eacute;alisation</b></p><div><img src="realisation.png" alt="R&eacute;alisation"></div></div><div class="figure"><a name="d0e267"></a><p class="title"><b>Figure&nbsp;5.&nbsp;D&eacute;pendance</b></p><div><img src="dependance.png" alt="D&eacute;pendance"></div></div><p>Parmi les associations, on distingue les agr&eacute;gations et compositions.</p><div class="figure"><a name="d0e273"></a><p class="title"><b>Figure&nbsp;6.&nbsp;Agr&eacute;gation</b></p><div><img src="agregation.png" alt="Agr&eacute;gation"></div></div><div class="figure"><a name="d0e277"></a><p class="title"><b>Figure&nbsp;7.&nbsp;Exemple (extrait des specs. UML 1.4)</b></p><div><img src="polygonUML.png" alt="Exemple (extrait des specs. UML 1.4)"></div></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="d0e281"></a>2.3.&nbsp;Repr&eacute;sentation des associations et d&eacute;pendances entre classes</h3></div></div><div></div></div><p>Le relations se classent en deux cat&eacute;gories : <span class="emphasis"><em>&agrave; long terme</em></span> et <span class="emphasis"><em>&agrave; court terme</em></span>.</p><div class="itemizedlist"><ul type="disc"><li><p>Relation &agrave; long terme</p><p>Une relation entre deux objets est qualifi&eacute;e de <span class="emphasis"><em>structurelle</em></span> lorsque la dur&eacute;e de vie du lien de cette relation est sup&eacute;rieure &agrave; la dur&eacute;e de vie du message qui lie ces objets. Dans ce cas nous avons &agrave; faire &agrave; une <span class="emphasis"><em>association</em></span> (le plus souvent repr&eacute;sent&eacute;e par un attribut).</p></li><li><p>Relation &agrave; court terme</p><p> Une <span class="emphasis"><em>d&eacute;pendance</em></span> (au sens relation UML) est l'expression d'un lien &agrave; court terme, qui ne dure que le temps d'ex&eacute;cution d'un message (passage d'arguments, variable locale, par exemple.).</p></li></ul></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="d0e312"></a>2.4.&nbsp;Les 2 grandes fonctions de l'h&eacute;ritage</h3></div></div><div></div></div><p>Dans la pratique, il y a trois principales raisons d'utiliser l'h&eacute;ritage :</p><div class="itemizedlist"><ul type="disc"><li><p><span class="emphasis"><em>H&eacute;ritage d'interface</em></span> : Utilis&eacute; pour le <span class="emphasis"><em><span class="emphasis"><em>polymorphisme</em></span></em></span> et associ&eacute; &agrave; la notion de <span class="emphasis"><em>type</em></span>.</p><div class="orderedlist"><ol type="1"><li><p>Une classe h&eacute;rite d'une interface : On dit que la classe <span class="emphasis"><em>r&eacute;alise</em></span> (impl&eacute;mente) une interface (donne corps aux op&eacute;rations).</p></li><li><p>Une interface h&eacute;rite d'une autre interface : Cr&eacute;ation d'un <span class="emphasis"><em>sous-type</em></span>, par extension du contrat (ajout de nouvelles op&eacute;rations).</p></li></ol></div></li><li><p><span class="emphasis"><em>H&eacute;ritage d'impl&eacute;mentation</em></span> : Utilis&eacute; pour la <span class="emphasis"><em><span class="emphasis"><em>r&eacute;utilisation</em></span></em></span>. </p><div class="orderedlist"><ol type="1"><li><p>Une classe h&eacute;rite d'une autre classe. Une partie du code est &laquo;&nbsp;<span class="quote">ouverte</span>&nbsp;&raquo; aux classes descendantes, ce qui fait dire par certains que l'h&eacute;ritage d'impl&eacute;mentation tue l'encapsulation.</p></li></ol></div></li></ul></div><p>Les langages ne font pas toujours une distinction nette de ces concepts. En effet une classe est pr&eacute;sent&eacute;e comme un tout compos&eacute; d'une interface (un type) <span class="emphasis"><em>et</em></span> d'une impl&eacute;mentation.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="1" width="80%"><tr><td rowspan="2" align="center" valign="top" width="25"><img src="images/note.png"></td><td>Java et l'h&eacute;ritage</td></tr><tr><td colspan="1" align="left" valign="top"><p>Java fait la diff&eacute;rence entre l'h&eacute;ritage d'interface (<span class="emphasis"><em>implements</em></span>) et l'h&eacute;ritage d'impl&eacute;mentation (<span class="emphasis"><em>extends</em></span>). Une classe peut &ecirc;tre vue comme un type (op&eacute;rations publiques) et une impl&eacute;mentation (m&eacute;thodes et attributs), dans ces conditions une classe peut se dispenser de r&eacute;f&eacute;rencer explicitement une interface. </p><table border="0" bgcolor="#E0E0E0" width="100%"><tr><td><pre class="programlisting">
<span class="bold"><b>class</b></span> Vehicule {                                   <span class="bold"><b>interface</b></span> IFVehicule {
   private String immatriculation;                     public String getImmatriculation();
   ...                                     &lt;==&gt;    }
   public String getImmatriculation() {             <span class="bold"><b>class</b></span> Vehicule <span class="bold"><b>implements</b></span> IFVehicule { 
      return this.immatriculation;                     private String immatriculation; 
   }                                                   ...
   ...                                                 public String getImmatriculation() { 
}                                                         return this.immatriculation; 
                                                       }
                                                   }   
</pre></td></tr></table><p>Un objet peut jouer plusieurs r&ocirc;les (sa classe impl&eacute;mente plusieurs interfaces).</p><p>Un m&ecirc;me r&ocirc;le peut &ecirc;tre jou&eacute; par des objets de classes diff&eacute;rentes (qui impl&eacute;mente la m&ecirc;me interface).</p></td></tr></table></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="d0e394"></a>2.5.&nbsp;Diff&eacute;rentes perspectives d'une vue</h3></div></div><div></div></div><p>Les diagrammes UML ne sont pas fig&eacute;s &agrave; un niveau de d&eacute;tail, un m&ecirc;me point de vue peut &ecirc;tre repr&eacute;sent&eacute; avec diff&eacute;rents niveaux de granularit&eacute;. On retient g&eacute;n&eacute;ralement 3 niveaux <span class="emphasis"><em>conceptuel, sp&eacute;cification</em></span> et <span class="emphasis"><em>impl&eacute;mentation</em></span>,  (Cook, S. and Daniels, J. Designing Object Systems: object-oriented modeling with Syntropy, Prentice Hall International, Hemel Hempstead, UK, 1994.), mentionn&eacute;s par Martin Fowler <a href="http://www2.awl.com/cseng/titles/0-201-89542-0/techniques/class.htm" target="_top"> ici </a>.</p><div class="itemizedlist"><ul type="disc"><li><p><span class="emphasis"><em>Conceptuel</em></span> : niveau essentiel [Cook, Daniels], domaine m&eacute;tier [Catalysis]</p></li><li><p><span class="emphasis"><em>Sp&eacute;cifications</em></span> : interface (des composants [Catalysis])</p></li><li><p><span class="emphasis"><em>Impl&eacute;mentation</em></span> : vue interne, proche du code (internal design [Catalysis])</p></li></ul></div><p>Certaines pratiques [Catalysis, XP] ajoutent &agrave; cet axe vertical (du plus haut - conceptuel - au plus bas  - le code -), un axe horizontal pr&eacute;cisant la <span class="emphasis"><em>port&eacute;e</em></span> (<span class="emphasis"><em>scope</em></span>). Par exemple un diagramme montrant une collaboration d'objets, gagnerait &agrave; pr&eacute;ciser le niveau (par exemple Sp&eacute;cification) et la port&eacute;e (par exemple le sous-syst&egrave;me que cette collaboration sert, ou le cas d'utilisation concern&eacute;).</p><div class="figure"><a name="d0e432"></a><p class="title"><b>Figure&nbsp;8.&nbsp;Niveaux et impacts</b></p><div><img src="niveauxUML.png" alt="Niveaux et impacts"></div></div><p><span class="emphasis"><em>Exemple</em></span></p><div class="figure"><a name="d0e439"></a><p class="title"><b>Figure&nbsp;9.&nbsp;Trois perspectives</b></p><div><img src="3perspectives.png" alt="Trois perspectives"></div></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="d0e443"></a>2.6.&nbsp;Exercices</h3></div></div><div></div></div><p><span class="emphasis"><em>Exercice 1</em></span></p><p>Produire un diagramme de classe UML &agrave; partir des &eacute;l&eacute;ments ci-dessous.</p><table border="0" bgcolor="#E0E0E0" width="100%"><tr><td><pre class="programlisting">
class Point { 
  protected int x; 
  protected int y; 
  public int getX(){return this.x;} 
  public void setX(int nouv_x){
    if (this.x != nouv_x)
       this.x = nouv_x;
  } 
  public int getY(){return this.y;}
  public void setY(int nouv_y){
    if (this.y != nouv_y) 
      this.y = nouv_y;
  }
  public Point() { super(); } 
}
class Point3D extends Point { 
  protected int z; 
  public int getZ(){return this.z;} 
  public void setZ(int nouv_z) {
    if (this.z != nouv_z) 
      this.z = nouv_z;
  }
  public Point3D() {super();}
}

interface Colorable { 
  public int getCouleur(); 
  public void setCouleur(int couleur); 
} 

class Point3DCouleur extends Point3D implements Colorable { 
  protected int couleur; 
  public int getCouleur() {return this.couleur;} 
  public void setCouleur (int couleur) { this.couleur = couleur; } 
  public Point3DCouleur() {super();} 
}
</pre></td></tr></table><p><span class="emphasis"><em>Exercice 2</em></span></p><p>Concevoir un diagramme de classe fid&egrave;le &agrave; l'impl&eacute;mentation du mod&egrave;le <span class="emphasis"><em>pull</em></span> du design pattern Observateur [Gof] ci-dessous :</p><table border="0" bgcolor="#E0E0E0" width="100%"><tr><td><pre class="programlisting">
public interface Observer {
  public void update(Observable o); 
}
 
public class Observable {
  Collection observateurs; 
  public void notify() { 
    Iterator it = observateurs.iterator();
    while (it.hasNext()) {
        Observer obs = (Observer) it.next();
        obs.update(this);
    }
  }

public void addObserver(Observer o) { observateurs.add(o); }
  ... 
}
  
public class Bilan extends Observable {
    void setChange() { notify(); }
    ... 
} 
  
public class UIGraphe implements Observer { 
    public UIGraphe(Observable o) { o.addObserver(this); } 
    public void update(Observable o) { 
       Bilan unbilan = (Bilan) o; 
       double compteResultat = unbilan.getCompteResultat();
       ... 
    } 
    ... 
}

</pre></td></tr></table></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e463"></a>3.&nbsp;Quelques grands principes</h2></div></div><div></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="d0e466"></a>3.1.&nbsp;Avertissement : YAGNI</h3></div></div><div></div></div><p>En conception (<span class="emphasis"><em>design</em></span>), il n'existe pas de r&egrave;gles strictes &agrave; appliquer, &agrave; l'image des <span class="emphasis"><em>formes normales</em></span> en analyse de donn&eacute;es (quitte &agrave; les enfreindre ensuite), mais des principes guidant la conception.</p><p>Pourquoi parler de guides et non de r&egrave;gles ?</p><p>Il n'est pas conseiller de vouloir toujours "faire du g&eacute;n&eacute;rique tout de suite", au risque de consommer du temps inutilement.</p><p>YAGNI veut dire <span class="emphasis"><em>"You aren't gonna need it"</em></span> (<span class="bold"><b>Vous n'allez pas avoir besoin de lui</b></span>). C'est un principe de pr&eacute;caution fondamental d'Extreme Programming, qui invite &agrave; la simplicit&eacute;, mais pas n'importe laquelle... Si le sujet vous int&eacute;resse, l'ouvrage de Kent Beck est reconnu comme une excellente introduction en la mati&egrave;re (<a href="#ref">R&eacute;f&eacute;rences</a>).</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="d0e491"></a>3.2.&nbsp;Principe d'Ouverture/Fermeture</h3></div></div><div></div></div><div class="itemizedlist"><ul type="disc"><li><p><span class="emphasis"><em>Principe d'Ouverture/Fermeture ---- <span class="emphasis"><em>Open-Closed Principle - OCP</em></span></em></span></p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="1" width="80%"><tr><td rowspan="2" align="center" valign="top" width="25"><img src="images/note.png"></td><td>OCP</td></tr><tr><td colspan="1" align="left" valign="top"><table border="0" bgcolor="#E0E0E0" width="100%"><tr><td><pre class="programlisting"><span class="emphasis"><em>Tout module (package, classe, m&eacute;thode) doit &ecirc;tre ouvert aux extensions mais ferm&eacute;
aux modifications.

</em></span></pre></td></tr></table></td></tr></table></div><p>Ce principe, que l'on doit au travail de Bertrand Meyer, est consid&eacute;r&eacute; comme le plus important des principes en conception objet [JOUP]. Ces implications sont nombreuses (Design by Contrat) et font l'objet d'autres principes (LSP, DIP...).</p><div class="itemizedlist"><ul type="circle"><li><p><span class="emphasis"><em>Ouvert aux extensions</em></span></p><p>Comprendre : le <span class="emphasis"><em>comportement</em></span> du syst&egrave;me devrait &ecirc;tre <span class="emphasis"><em>extensible</em></span>. En effet, aucun syst&egrave;me n'est &agrave; l'abri de nouveaux besoins. Les parties changeantes d'un syst&egrave;me doivent &ecirc;tre abtraites, offrant ainsi une ouverture pour d'autres impl&eacute;mentation que celles initialement pr&eacute;vues.</p><p>Techniques utilis&eacute;es : Abstraction (classe abstraite, interface), polymorphisme (ne pas tester le type d'un objet avant de lui envoyer un message) et sous-traitance d'instanciation (factory).</p></li><li><p><span class="emphasis"><em>Ferm&eacute; aux modifications</em></span></p><p>L'impl&eacute;mentation des classes/op&eacute;rations/attributs ne doit pas &ecirc;tre soumise aux changements.</p><p>Techniques utilis&eacute;es :</p><div class="itemizedlist"><ul type="disc"><li><p>Rendre <span class="emphasis"><em>priv&eacute;s</em></span> tous les attributs (principe de r&eacute;tention d'information de B. Meyer)</p></li><li><p>Seuls sont visibles (<span class="emphasis"><em>public</em></span>), les m&eacute;thodes qui impl&eacute;mentent les op&eacute;rations (une &laquo;&nbsp;<span class="quote">op&eacute;ration</span>&nbsp;&raquo; r&eacute;alise un service).</p></li><li><p>Les invariants algorithmiques sont impl&eacute;ment&eacute;s, les parties changeantes sont repr&eacute;sent&eacute;es par des m&eacute;thodes abstraites.</p></li></ul></div></li></ul></div><p>Illustration</p><div class="figure"><a name="d0e554"></a><p class="title"><b>Figure&nbsp;10.&nbsp;Non respect d'OCP</b></p><div><img src="no-ocp-1.png" alt="Non respect d'OCP"></div></div><p>Cet exemple ne respecte pas OCP :</p><div class="itemizedlist"><ul type="circle"><li><p>Les attributs ne sont pas cach&eacute;s (le signe + signifie <span class="emphasis"><em>public</em></span>).</p></li><li><p>La m&eacute;thode <span class="emphasis"><em>getSalaire</em></span> n'est pas ouverte aux changements (une nouvelle cat&eacute;gorie de personnel n&eacute;cessitera de recoder le comportement de cette m&eacute;thode, en autres).</p></li></ul></div><div class="figure"><a name="d0e573"></a><p class="title"><b>Figure&nbsp;11.&nbsp;Non respect d'OCP</b></p><div><img src="no-ocp-2.png" alt="Non respect d'OCP"></div></div><p>Cet exemple ne respecte pas OCP :</p><div class="itemizedlist"><ul type="circle"><li><p>Les attributs ne sont pas cach&eacute;s.</p></li><li><p>La m&eacute;thode <span class="emphasis"><em>getSalaire</em></span>  n'est toutjours pas ouverte aux changements, elle a besoin de tester la classe de l'instance dans sa d&eacute;finition (n'utilise pas le polymorphisme).</p></li></ul></div><div class="figure"><a name="d0e589"></a><p class="title"><b>Figure&nbsp;12.&nbsp;Non respect d'OCP</b></p><div><img src="no-ocp-3.png" alt="Non respect d'OCP"></div></div><p>Cet exemple ne respecte pas OCP :</p><div class="itemizedlist"><ul type="circle"><li><p>Les attributs ne sont pas cach&eacute;s aux classes descendantes.</p></li><li><p>Si elle n'est utilis&eacute;e que par <span class="emphasis"><em>getSalaire</em></span>, la m&eacute;thode <span class="emphasis"><em>calculerCommission</em></span> devrait &ecirc;tre cach&eacute;e.</p></li></ul></div><div class="figure"><a name="d0e608"></a><p class="title"><b>Figure&nbsp;13.&nbsp;Respect d'OCP</b></p><div><img src="yes-ocp.png" alt="Respect d'OCP"></div></div><p>Nous appliquons OCP &agrave; la classe <tt class="literal">Repr&eacute;sentant</tt> si nous "gelons" la m&eacute;thode <tt class="literal">Repr&eacute;sentant::getSalaire</tt> et ne fournissons aucun moyen aux classes descendantes de modifier le <tt class="literal">ca</tt>.</p><p>Une classe descendante, par exemple <tt class="literal">Repr&eacute;sentantInterim h&eacute;rite de Repr&eacute;sentant</tt>, pourra personnaliser le comportement de <tt class="literal">Repr&eacute;sentant::getSalaire</tt> en impl&eacute;mentant diff&eacute;rement la m&eacute;thode prot&eacute;g&eacute;e <tt class="literal">Repr&eacute;sentantInterim::calculerCommission</tt>.</p><p>La plupart du temps ce type de solution fait intervenir une <tt class="literal">Interface</tt>.</p><p><span class="emphasis"><em>Quand appliquer OCP ?</em></span></p><p>
Les donn&eacute;es devraient toujours &ecirc;tre cach&eacute;es. Dans ce cas, elles ne sont accessibles par des op&eacute;rations (dite <span class="emphasis"><em>getter/setter</em></span> ou par un mecanisme plus puissant : les propri&eacute;t&eacute;s, <span class="emphasis"><em>property</em></span>, respectant ainsi le principe d'acc&egrave;s uniforme de B. Meyer).</p><p>Par contre, il convient d'&ecirc;tre plus r&eacute;serv&eacute; quant &agrave; une mise en oeuvre syst&eacute;matique de l'abstraction (via des interfaces) qui augmente de fa&ccedil;on non n&eacute;gligeable le nombre de classes du syst&egrave;me, et le temps de d&eacute;veloppment. On appliquera OCP sur des parties &laquo;&nbsp;<span class="quote"> qui en valent la peine</span>&nbsp;&raquo;, &agrave; forte probalit&eacute; de changements.</p><p>A ce sujet, <a href="http://www.design-up.com" target="_top">Design-Up</a> nous conseille <span class="emphasis"><em>d'identifier correctement les points d'ouverture/fermeture de l'application, en s'inspirant :</em></span></p><div class="itemizedlist"><ul type="circle"><li><p><span class="emphasis"><em>Des besoins d'&eacute;volutivit&eacute; exprim&eacute;s par le client</em></span></p></li><li><p><span class="emphasis"><em>Des besoins de flexibilit&eacute; pressentis par les d&eacute;veloppeurs</em></span></p></li><li><p><span class="emphasis"><em>Des changements r&eacute;p&eacute;t&eacute;s constat&eacute;s au cours du d&eacute;veloppement</em></span></p></li></ul></div><p><span class="emphasis"><em>La mise en oeuvre de ce principe reste donc une affaire de bon sens, sachant que la meilleure heuristique reste la suivante : <span class="emphasis"><em>on n'applique l'OCP que lorsque cela simplifie le design.</em></span></em></span>
</p></li><li><p><span class="emphasis"><em>Technique utilis&eacute;e</em></span></p><div class="itemizedlist"><ul type="circle"><li><p>Impl&eacute;menter les parties stables (classe, m&eacute;thode) et abstraire les parties changeantes (interface) - voir le design pattern Template/Hook - </p></li><li><p>Encapsuler syst&eacute;matiquement les attributs.</p></li></ul></div></li></ul></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="d0e692"></a>3.3.&nbsp;Principe de Substitution de Liskov</h3></div></div><div></div></div><div class="itemizedlist"><ul type="disc"><li><p><span class="emphasis"><em>Principe de Substitution de Liskov ---<span class="emphasis"><em>Liskov Substitution Principle - LSP</em></span></em></span></p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="1" width="80%"><tr><td rowspan="2" align="center" valign="top" width="25"><img src="images/note.png"></td><td>LSP</td></tr><tr><td colspan="1" align="left" valign="top"><p><span class="emphasis"><em>Les m&eacute;thodes qui utilisent des objets d'une classe doivent pouvoir utiliser des objets d&eacute;riv&eacute;s de cette classe sans m&ecirc;me le savoir.</em></span></p></td></tr></table></div><p>LSP est le fruit d'un travail du Barbara Liskov qui est d&eacute;riv&eacute; du concept de <span class="emphasis"><em>Design by Contrat</em></span> de Bertrand Meyer, en particulier les notions de pr&eacute;-condition et post-condition.</p><p>Une <span class="emphasis"><em>pr&eacute;-condition</em></span> est un contrat que doit respecter le client d'un service. Si une pr&eacute;-condition d'un m&eacute;thode ne peut &ecirc;tre respect&eacute;e, cette m&eacute;thode ne doit pas &ecirc;tre appel&eacute;e.</p><p>Une <span class="emphasis"><em>post-condition</em></span> est un contrat que doit respecter le fournisseur d'un service. Si une m&eacute;thode ne peut assur&eacute;e une post-condition, elle ne doit pas retourner.</p></li><li><p><span class="emphasis"><em>Quand appliquer LSP ?</em></span></p><p>Chaque fois que l'h&eacute;ritage est mise en oeuvre : H&eacute;ritage d'impl&eacute;mentation (red&eacute;finition de m&eacute;thodes) et h&eacute;ritage d'interface (red&eacute;finition de assertions).</p><p></p></li><li><p><span class="emphasis"><em>Technique utilis&eacute;e</em></span></p><p>Contr&ocirc;ler les contrats par une gestion des exceptions.</p><p>Remarque : Il est tr&egrave;s difficile, en l'absence de pr&eacute; et post conditions, de v&eacute;rifier le respect de ce principe.</p><p>Les pr&eacute;-conditions d&eacute;finies par les sous-classes ne doivent pas &ecirc;tre plus restrictives que celles h&eacute;rit&eacute;es.</p><p>Les post-conditions d&eacute;finies par les sous-classes ne doivent pas &ecirc;tre plus larges que celles h&eacute;rit&eacute;es.</p><p><span class="emphasis"><em>Exemple de non respect de LSP</em></span></p><table border="0" bgcolor="#E0E0E0" width="100%"><tr><td><pre class="programlisting">
 interface A {
  /**
   @pre  : x in [1..10]
   @post : m(x) in [1..20]
  */
   int m(int x) throws NumberFormatException;
 }
 
 interface B extends A {
  /**
   @pre  : x in [1..5]
   @post : m(x) in [0..20]
  */
  int m(int x) throws Exception;
 }

 class C implements B {
  public int  m(int x) throws NumberFormatException { 
    System.out.println("C::m()");
    throw new NumberFormatException();
  }
 }
</pre></td></tr></table></li></ul></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="d0e747"></a>3.4.&nbsp;Principe d'Inversion de Contr&ocirc;le</h3></div></div><div></div></div><div class="itemizedlist"><ul type="disc"><li><p><span class="emphasis"><em>Principe d'Inversion de Contr&ocirc;le ---<span class="emphasis"><em>Inversion Of Control Principle - IoC </em></span></em></span> connu &eacute;galement sous le nom de <span class="emphasis"><em>Principe d'Inversion de Contr&ocirc;le ---<span class="emphasis"><em>Dependency Inversion Principle - DIP</em></span></em></span></p><p>Voir ici : <a href="http://www.betaversion.org/~stefano/linotype/news/38/" target="_top">IoC</a>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="1" width="80%"><tr><td rowspan="2" align="center" valign="top" width="25"><img src="images/note.png"></td><td>IoC - DIP</td></tr><tr><td colspan="1" align="left" valign="top"><table border="0" bgcolor="#E0E0E0" width="100%"><tr><td><pre class="programlisting"><span class="emphasis"><em>
A. Les modules de haut niveau ne doivent pas d&eacute;pendre de modules de bas niveau.
   Tous deux doivent d&eacute;pendre d'abstractions. 
   
B. Les abstractions ne doivent pas d&eacute;pendre de d&eacute;tails. 
   Les d&eacute;tails doivent d&eacute;pendre d'abstractions.

</em></span></pre></td></tr></table></td></tr></table></div><p>IoC. Contrairement aux id&eacute;es re&ccedil;ues, les modules de haut niveau ne doivent pas n&eacute;cessairement d&eacute;pendre directement de modules de bas niveau. Si cette d&eacute;pendance existe, le changement d'un module de bas niveau risque d'avoir un impact direct sur l'ensemble des modules qui lui sont d&eacute;pendants (recompilation en cha&icirc;ne).</p><p>Illustration (<span class="emphasis"><em>Design-up</em></span>).</p><div class="figure"><a name="d0e781"></a><p class="title"><b>Figure&nbsp;14.&nbsp;Avant DIP (Design-up)</b></p><div><img src="avantDIP.png" alt="Avant DIP (Design-up)"></div></div><p>Selon ce principe, la relation de d&eacute;pendance doit &ecirc;tre invers&eacute;e :<span class="emphasis"><em>Les modules de bas niveau doivent se conformer &agrave; des interfaces d&eacute;finies et utilis&eacute;es par les modules de haut niveau.</em></span></p><div class="figure"><a name="d0e789"></a><p class="title"><b>Figure&nbsp;15.&nbsp;Apr&egrave;s DIP (Design-up)</b></p><div><img src="apresDIP.png" alt="Apr&egrave;s DIP (Design-up)"></div></div></li><li><p><span class="emphasis"><em>Quand appliquer IoC - DIP ?</em></span></p><p>Pour la conception de modules g&eacute;n&eacute;riques. Le cas le plus typique est bien entendu le <span class="emphasis"><em>framework</em></span>, qui est par nature hautement r&eacute;utilisable.</p><p>Lorsque que l'OCP est fortement envisag&eacute;.</p></li><li><p><span class="emphasis"><em>Technique utilis&eacute;e</em></span></p><p>Ce sont les techniques utilis&eacute;es pour OCP, coupl&eacute;es avec LSP.</p><p>Plus pr&eacute;cisemment, lorsqu'un module A d&eacute;pend d'un module de bas niveau B (couplage concret), on cr&eacute;e une interface I que le module A utilise (couplage abstrait) et le module B r&eacute;alise.  Le module A est alors lib&eacute;r&eacute; du module B, devenu substituable.</p><div class="figure"><a name="d0e812"></a><p class="title"><b>Figure&nbsp;16.&nbsp;Appliquer DIP</b></p><div><img src="dip.png" alt="Appliquer DIP"></div></div><p><span class="emphasis"><em>Exemple de non respect de DIP</em></span></p><table border="0" bgcolor="#E0E0E0" width="100%"><tr><td><pre class="programlisting">
class Client {
  OracleDB oracle;
  ...
  static Client getInstance(String id){
    Client res = null;
    String sql = "Select ...";
    ...
    ResultSet rs = oracle.execute(sql);
    ...
    return res;
  }
}

class OracleDB {
  String chaineConnect = "...";
  ...
  ResultSet execute(String sql) { ... }
  ...
}
</pre></td></tr></table><p><span class="emphasis"><em>M&ecirc;me exemple respectant DIP</em></span></p><table border="0" bgcolor="#E0E0E0" width="100%"><tr><td><pre class="programlisting">
class Client {
  <span class="bold"><b>DB db;</b></span>
  ...
  static Client getInstance(String id){
    Client res = null;
    String sql = "Select ...";
    ...
    ResultSet rs = <span class="bold"><b>db</b></span>.execute(sql);
    ...
    return res;
  }
}

<span class="bold"><b>interface DB</b></span> {
  ...
  ResultSet execute(String sql);
  ...
}

class OracleDB <span class="bold"><b>implements DB</b></span> {
  String chaineConnect = "...";
  ...
  ResultSet execute(String sql) { ... }
  ...
}
</pre></td></tr></table><p> </p><div class="figure"><a name="d0e840"></a><p class="title"><b>Figure&nbsp;17.&nbsp;Autre exemple IoC [JOUP]</b></p><div><img src="dip-joup.png" alt="Autre exemple IoC [JOUP]"></div></div><p>Voici un exemple d'impl&eacute;mentation : </p><table border="0" bgcolor="#E0E0E0" width="100%"><tr><td><pre class="programlisting">
class Compte {
  private TypeCompte _typec;
  
  public Compte(String typeCompte) throws Exception {
     Class c = Class.forName(typeCompte);
     this._typec = (TypeCompte) c.newInstance();
  }
  
  pubic void deposer (float montant){
     this._typec.deposer(montant);
  }
}

interface TypeCompte {
  void deposer(float montant);
}

class CompteEpargne implements TypeCompte {
  public void deposer(float montant){
    System.out.println();
    System.out.println("Montant d&eacute;pos&eacute; sur le compte &eacute;pargne : " + montant);
    System.out.println();
    System.out.println();
  }
}  
 
class CompteCheque implements TypeCompte {
  public void deposer(float montant){
    System.out.println();
    System.out.println("Montant d&eacute;pos&eacute; sur le compte ch&egrave;que : " + montant);
    System.out.println();
    System.out.println();
  }
}
</pre></td></tr></table><p>On constate que le couplage abstrait est respect&eacute;. Le lien entre un objet de la classe Compte et objet de type TypeCompte est r&eacute;alis&eacute; par une simple chaine de caract&egrave;res pass&eacute;e au constructeur de Compte. Le sch&eacute;ma est : </p><table border="0" bgcolor="#E0E0E0" width="100%"><tr><td><pre class="programlisting">
Class c = Class.forName(&lt;nom d'une classe enfant&gt;);
&lt;Une classe parent&gt; ancetre = (&lt;Une classe parent&gt;) c.newInstance();
</pre></td></tr></table><p>Toute fois cette approche n&eacute;cessite, pour des questions de s&eacute;curit&eacute;, de prendre quelques pr&eacute;cautions. En g&eacute;n&eacute;ral, on applique quelques unes des id&eacute;es pr&eacute;sent&eacute;es par les designs patterns de type Cr&eacute;ateur (<span class="emphasis"><em>factory</em></span>).</p><div class="itemizedlist"><p class="title"><b>Exercice</b></p><ul type="circle"><li><p>Concevoir un programme (en mode console) qui cr&eacute;e un compte ch&egrave;que et y d&eacute;pose 300 euro, puis 200 euro sur un compte epargne.</p></li></ul></div></li></ul></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="d0e863"></a>3.5.&nbsp;Remarque</h3></div></div><div></div></div><p>Il existe une relation &eacute;troite entre ces trois principes. DIP, associ&eacute; &agrave; LSP,  nous explique comment adh&eacute;rer &agrave; OCP. En effet, les parties ferm&eacute;es (OCP) doivent s'appuyer sur des interfaces (IoC Principle) clairement exprim&eacute;es et correctement r&eacute;alis&eacute;es (LSP).

</p><div class="figure"><a name="d0e868"></a><p class="title"><b>Figure&nbsp;18.&nbsp;Les trois grands principes </b></p><div><img src="ocpdiplsp.png" alt="Les trois grands principes"></div></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="d0e872"></a>3.6.&nbsp;Principe de s&eacute;paration des interfaces</h3></div></div><div></div></div><div class="itemizedlist"><ul type="disc"><li><p><span class="emphasis"><em>Principe de s&eacute;paration des interfaces ---<span class="emphasis"><em>Interface Segregation Principle - ISP</em></span></em></span></p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="1" width="80%"><tr><td rowspan="2" align="center" valign="top" width="25"><img src="images/note.png"></td><td>ISP</td></tr><tr><td colspan="1" align="left" valign="top"><table border="0" bgcolor="#E0E0E0" width="100%"><tr><td><pre class="programlisting"><span class="emphasis"><em>

Les clients ne doivent pas &ecirc;tre forc&eacute;s de d&eacute;pendre d'interfaces qu'ils n'utilisent pas.

</em></span></pre></td></tr></table></td></tr></table></div><p>Les op&eacute;rations d'une interface doivent servir le m&ecirc;me but.</p><div class="figure"><a name="d0e891"></a><p class="title"><b>Figure&nbsp;19.&nbsp;Application d'ISP</b></p><div><img src="isp.png" alt="Application d'ISP"></div></div></li><li><p><span class="emphasis"><em>Quand appliquer ISP ?</em></span></p><p>Lors de la cr&eacute;ation d'une interface, ISP aide &agrave; mettre met l'accent sur sa coh&eacute;rence.</p></li><li><p><span class="emphasis"><em>Technique utilis&eacute;e</em></span></p><p>Cr&eacute;ation d'interfaces et h&eacute;ritage multiple.</p></li></ul></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="d0e907"></a>3.7.&nbsp;Principe de R&eacute;utilisation par Composition</h3></div></div><div></div></div><div class="itemizedlist"><ul type="disc"><li><p><span class="emphasis"><em>Principe de R&eacute;utilisation par Composition ---<span class="emphasis"><em>Composite Reuse Principle - CRP</em></span></em></span></p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="1" width="80%"><tr><td rowspan="2" align="center" valign="top" width="25"><img src="images/note.png"></td><td>CRP</td></tr><tr><td colspan="1" align="left" valign="top"><table border="0" bgcolor="#E0E0E0" width="100%"><tr><td><pre class="programlisting"><span class="emphasis"><em>

Pr&eacute;f&eacute;rer la composition d'objets &agrave; l'h&eacute;ritage de classes.

</em></span></pre></td></tr></table></td></tr></table></div><p>Ce principe est discut&eacute; pour la premi&egrave;re fois dans Gof. Les d&eacute;veloppeurs ont tendance &agrave; abuser de l'h&eacute;ritage d'impl&eacute;mentation.</p></li><li><p><span class="emphasis"><em>Quand appliquer CRP ?</em></span></p><p>Prenons le probl&egrave;me &agrave; l'envers. Coad a d&eacute;fini 5 r&egrave;gles qui doivent &ecirc;tre toutes v&eacute;rifi&eacute;es pour une bonne utilisation de l'h&eacute;ritage :</p><div class="orderedlist"><ol type="1"><li><p>La relation de sous-type est &laquo;&nbsp;<span class="quote">est une sorte sp&eacute;ciale de</span>&nbsp;&raquo; et non &laquo;&nbsp;<span class="quote">est un r&ocirc;le jou&eacute; par un</span>&nbsp;&raquo;.</p></li><li><p>Un objet de la classe n'a jamais besoin de transmuter (changer de classe).</p></li><li><p>La sous-classe &eacute;tend mais ne nullifie pas les comportements h&eacute;rit&eacute;s.</p></li><li><p>Ne pas sous-classer pour de simples raisons pratiques, pour simplifier des probl&egrave;mes techniques.</p></li><li><p>A l'int&eacute;rieur du domaine du probl&egrave;me, la relation est &laquo;&nbsp;<span class="quote">est une sorte sp&eacute;ciale de {r&ocirc;les, transactions ou choses}</span>&nbsp;&raquo;.</p></li></ol></div><p>Si l'ensemble de ces 5 r&egrave;gles n'est pas v&eacute;rifi&eacute;, alors la d&eacute;l&eacute;gation (composition d'objets) doit &ecirc;tre pr&eacute;f&eacute;r&eacute;e &agrave; l'h&eacute;ritage.</p></li><li><p><span class="emphasis"><em>Technique utilis&eacute;e</em></span></p><p>D&eacute;l&eacute;gation.</p><div class="figure"><a name="d0e965"></a><p class="title"><b>Figure&nbsp;20.&nbsp;Exemple de non respect de CRP</b></p><div><img src="avantCRP.png" alt="Exemple de non respect de CRP"></div></div><p> </p><table border="0" bgcolor="#E0E0E0" width="100%"><tr><td><pre class="programlisting">
abstract class Employe {
  ...
  abstract public float getSalaire()
}

class Developpeur extends Employe {
  public float getSalaire() { ... }
  ...
}

class ChefDeProjet extends Employe {
  public float getSalaire() { ... }
  ...
}

</pre></td></tr></table><p>V&eacute;rifions les r&egrave;gles :</p><div class="orderedlist"><ol type="1"><li><p> Faux</p></li><li><p> Hum...</p></li><li><p>Vrai</p></li><li><p>Vrai</p></li><li><p>Vrai</p></li></ol></div><p>3 crit&egrave;res sur 5.</p><div class="figure"><a name="d0e993"></a><p class="title"><b>Figure&nbsp;21.&nbsp;Exemple de respect de CRP</b></p><div><img src="apresCRP.png" alt="Exemple de respect de CRP"></div></div><p> </p><table border="0" bgcolor="#E0E0E0" width="100%"><tr><td><pre class="programlisting">
class Employe {
  <span class="emphasis"><em>EmploiType emploi;</em></span>
  float getSalaire() { return emploi.getSalaire(); }
  ...
}

<span class="emphasis"><em>interface EmploiType</em></span> {
  public float getSalaire();
}

class Developpeur <span class="emphasis"><em>implements EmployeType</em></span> {
  public float getSalaire() { ... }
  ...
}

class ChefDeProjet <span class="emphasis"><em>implements EmployeType</em></span> {
  public float getSalaire() { ... }
  ...
}
</pre></td></tr></table></li></ul></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1013"></a>3.8.&nbsp;Exercice</h3></div></div><div></div></div><p>Voici un programme qui construit une page HTML repr&eacute;sentant les caract&egrave;res affichables de la table ASCII (code 32 &agrave; 127), accompagn&eacute;s de leur valeur ordinale exprim&eacute;e en base dix ou deux, selon l'argument fourni par l'utilisateur.</p><table border="0" bgcolor="#E0E0E0" width="100%"><tr><td><pre class="programlisting">

class TableAsciiToHTML {
  private char typeRepr;


  public TableAsciiToHTML(String typeRepr) {
    this.typeRepr= (typeRepr == null) ? 'd' : typeRepr.charAt(0);
    printHTML();
  }

  private void printHTML() {
    int deb = 32;
    int fin = 128;
    int nbCol = 10;
    int cpt = 0;
    System.out.println("&lt;html&gt;&lt;head /&gt;&lt;body&gt;&lt;center&gt;&lt;h1&gt;TABLE DE CARACTERES&lt;/h1&gt;");
    System.out.println("&lt;table border="1"&gt;");
    for (int i = deb; i &lt; fin; i++, cpt++) {
      if (cpt%nbCol == 0) {
         if (i&gt;deb)  System.out.println("&lt;/tr&gt;");
         System.out.println("&lt;tr&gt;");
      }
      System.out.println("&lt;td align=\"center\"&gt;");
      System.out.println("&lt;table border=\"1\"&gt; &lt;tr&gt;");
      System.out.println("&lt;td bgcolor=\"teal\" align=\"center\"&gt;");
      switch (this.typeRepr) {
       case 'd' :
         System.out.println(toDecString(i));
         break;
       case 'b' :
         System.out.println(toBinString(i));
         break;
       default :
         System.out.println(toDecString(i));
      }
      System.out.println("&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;");
      System.out.println("&lt;td bgcolor=\"#CC3300\" align=\"center\"&gt;");
      System.out.println(" &amp;#" + i + "; &lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/td&gt;");
    }
    System.out.println("&lt;/tr&gt;&lt;/table&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt;");
  }

  private String toDecString(int n) {
     return String.valueOf(n);
  }

  private String toBinString(int n) {
     return Integer.toBinaryString(n);
  }

}

public class AppTableAscii {
  static void main(String[] args) {
     String arg = (args.length&gt;0) ? args[0] : null;
     TableAsciiToHTML app = new TableAsciiToHTML(arg);
  }
}

</pre></td></tr></table><p>Recopier ce programme puis compiler le.</p><table border="0" bgcolor="#E0E0E0" width="100%"><tr><td><pre class="programlisting">
javac AppTableAscii.java
</pre></td></tr></table><p>Ex&eacute;cuter le en redirigeant la sortie standard vers une fichier portant l'extension <span class="emphasis"><em>.html</em></span>.</p><table border="0" bgcolor="#E0E0E0" width="100%"><tr><td><pre class="programlisting">
java AppTableAscii &gt; ascii.html
</pre></td></tr></table><p>Visualiser le r&eacute;sultat avec un navigateur.</p><p>Recommencer en passant une valeur ('b') en ligne de commande</p><table border="0" bgcolor="#E0E0E0" width="100%"><tr><td><pre class="programlisting">
java AppTableAscii <span class="emphasis"><em>b</em></span> &gt; ascii.html
</pre></td></tr></table><p>Visualiser le r&eacute;sultat avec un navigateur.</p><p>Bon, ok, le programme fonctionne. Toute fois il n'est pas tr&egrave;s propre, les parties extensibles ne sont pas abstraites.</p><p><span class="bold"><b>On souhaiterait proposer de nouvelles repr&eacute;sentations des entiers </b></span> <span class="emphasis"><em>sans avoir &agrave; retoucher l'existant (une fois retouch&eacute; bien entendu)</em></span>.</p><p>On vous demande d'appliquer OCP (et DIP) sur cet existant. La refonte de l'application ne doit pas entrainer de changement visible de son comportement, les fonctionnalit&eacute;s restent identiques et l'utilisateur n'y voit que du feu... Remarque : La refonte d'une partie du code d'une application, sans impact sur ses fonctionnalit&eacute;s est appel&eacute;e <span class="emphasis"><em>Refactoring</em></span>, une activit&eacute; quotidienne du d&eacute;veloppeur reconnue par eXtreme Programming.</p><p>Id&eacute;e : R&eacute;aliser un couplage abstrait entre la logique de l'application (contruction d'une page HTML) et la repr&eacute;sentation des nombres.</p><p>Objectif et test : Une fois l'application reconstruite, introduire une nouvelle repr&eacute;sentation des valeurs ordinales en base 16, et ce sans intervenir sur le code existant de l'application.</p><p>Coad et Mayfield [Java Design] pr&eacute;conisent la strat&eacute;gie suivante :</p><div class="orderedlist"><ol type="1"><li><p>Rechercher la caract&eacute;ristique polymorphe</p></li><li><p>Identifier un ensemble de noms de m&eacute;thodes correspondant &agrave; cette caract&eacute;ristique</p></li><li><p>Ajouter une interface</p></li><li><p>Identifier les impl&eacute;mentations</p></li></ol></div></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1075"></a>4.&nbsp;Correction de l'exercice Table Ascii - OCP DIP</h2></div></div><div></div></div><p>Coad et Mayfield [Java Design] pr&eacute;conisent la strat&eacute;gie suivante :</p><div class="orderedlist"><ol type="1"><li><p><span class="foreignphrase"><i class="foreignphrase">Rechercher la caract&eacute;ristique polymorphe</i></span></p><p>Le jeu de caract&egrave;res ? Possible si on &eacute;tend ceux-ci au jeu UNICODE.</p><p>La repr&eacute;sentation des valeurs ordinales de chacun des caract&egrave;res affich&eacute;s ? Certainement, c'est d&eacute;j&agrave; ce que r&eacute;alise le programme.</p><p>On retiendra donc cette derni&egrave;re caract&eacute;ristique : <span class="emphasis"><em>Repr&eacute;sentation des nombres.</em></span></p></li><li><p><span class="foreignphrase"><i class="foreignphrase">Identifier un ensemble de noms de m&eacute;thodes correspondant &agrave; cette caract&eacute;ristique</i></span></p><p>L'objectif &eacute;tant de repr&eacute;senter une valeur ordinales, un entier, dans une base donn&eacute;e constitu&eacute;e de symboles, eux-m&ecirc;me repr&eacute;sent&eacute;s sous la forme d'un caract&egrave;re. Une suite ordonn&eacute;e de caract&egrave;res est un type bien connu (String), nous proposons de nommer l'op&eacute;ration : </p><table border="0" bgcolor="#E0E0E0" width="100%"><tr><td><pre class="programlisting">
 String toString(int n)
 </pre></td></tr></table><p>Une fonction dont la valeur (une cha&icirc;ne de caract&egrave;re) est la repr&eacute;sention du nombre (n) qu'elle recoit en argument.</p></li><li><p><span class="foreignphrase"><i class="foreignphrase">Ajouter une interface</i></span></p><table border="0" bgcolor="#E0E0E0" width="100%"><tr><td><pre class="programlisting">
 interface Representation {
   String toString(int n);
 }
</pre></td></tr></table></li><li><p><span class="foreignphrase"><i class="foreignphrase">Identifier les impl&eacute;mentations</i></span></p><p>
 Concevons les deux classes d'impl&eacute;mentation de l'interface <span class="foreignphrase"><i class="foreignphrase">Representation</i></span> qui r&eacute;alisent la repr&eacute;sentation en base 10 et en base 2, conform&eacute;ment &agrave; l'existant. Rappel, les fonctionalit&eacute;s qui existent avant une activit&eacute; de refactoring, doivent absolument &ecirc;tre retrouv&eacute;es apr&egrave;s la refonte du code. </p><table border="0" bgcolor="#E0E0E0" width="100%"><tr><td><pre class="programlisting">
 class Decimal implements Representation {
  public String toString(int i) {  
      return String.valueOf(i);
  }
}

class Binaire implements Representation {
  public String toString(int i) {  
     return Integer.toBinaryString(i);
  }
}
 </pre></td></tr></table><p>Modifions la partie qui d&eacute;cide de la repr&eacute;sentation des nombres &agrave; appliquer (limit&eacute;e actuellement &agrave; seulement deux repr&eacute;sentations possibles) en la couplant &agrave; un objet, nomm&eacute; <span class="foreignphrase"><i class="foreignphrase">repr</i></span>, de type <span class="foreignphrase"><i class="foreignphrase">Repr&eacute;sentation</i></span>. </p><p>L'ancien code : </p><table border="0" bgcolor="#E0E0E0" width="100%"><tr><td><pre class="programlisting">

    System.out.println("&lt;table border=\"1\"&gt; &lt;tr&gt;");
    System.out.println("&lt;td bgcolor=\"teal\" align=\"center\"&gt;");
    switch (this.typeRepr) {
      case 'd' :
         System.out.println(toDecString(i));
         break;
      case 'b' :
         System.out.println(toBinString(i));
         break;
      default :
         System.out.println(toDecString(i));
    }
    System.out.println("&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;");
    System.out.println("&lt;td bgcolor=\"#CC3300\" align=\"center\"&gt;");
    System.out.println(" &amp;#" + i + "; &lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/td&gt;");

 </pre></td></tr></table><p>Le nouveau code :</p><table border="0" bgcolor="#E0E0E0" width="100%"><tr><td><pre class="programlisting">

    System.out.println("&lt;table border=\"1\"&gt; &lt;tr&gt;");
    System.out.println("&lt;td bgcolor=\"teal\" align=\"center\"&gt;");

    System.out.println(repr.toString(i)); 

    System.out.println("&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;");
    System.out.println("&lt;td bgcolor=\"#CC3300\" align=\"center\"&gt;");
    System.out.println(" &amp;#" + i + "; &lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/td&gt;");

 </pre></td></tr></table><p>L'objet responsable de la repr&eacute;sentation des valeurs ordinales est fournit par l'appelant &agrave; la cr&eacute;ation de l'application.</p><table border="0" bgcolor="#E0E0E0" width="100%"><tr><td><pre class="programlisting">
  public TableAsciiToHTML(Representation repr) {
      this.repr = repr;
      printHTML();
  }
 </pre></td></tr></table></li></ol></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1141"></a>4.1.&nbsp;Listing de la solution</h3></div></div><div></div></div><p>
      </p><table border="0" bgcolor="#E0E0E0" width="100%"><tr><td><pre class="programlisting">


interface Representation {
  String toString(int i);
}

class Decimal implements Representation {
  public String toString(int i) {  
      return String.valueOf(i);
  }
}

class Binaire implements Representation {
  public String toString(int i) {  
     return Integer.toBinaryString(i);
  }
}

class TableAsciiToHTML {
  private Representation repr;

  public TableAsciiToHTML(Representation repr) {
      this.repr = repr;
      printHTML();
  }
 
  private void printHTML() {
    int deb = 32;
    int fin = 128;
    int nbCol = 10;
    int cpt = 0;
    System.out.println("&lt;html&gt;&lt;head /&gt;&lt;body&gt;&lt;center&gt;&lt;h1&gt;TABLE DE CARACTERES&lt;h1&gt;");
    System.out.println("&lt;table border=\"1\"&gt;");
    System.out.println("&lt;tr&gt;");
    for (int i = deb; i &lt; fin; i++, cpt++) {
      if (cpt%nbCol == 0) {
         if (i&gt;deb)  System.out.println("&lt;/tr&gt;");
         System.out.println("&lt;tr&gt;");
      }
      System.out.println("&lt;td align=\"center\"");
      System.out.println("&lt;table border=\"1\"&gt; &lt;tr&gt;");
      System.out.println("&lt;td bgcolor=\"teal\" align=\"center\"&gt;");
      
      System.out.println(repr.toString(i));

      System.out.println("&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;");
      System.out.println("&lt;td bgcolor=\"#CC3300\" align=\"center\"&gt;");
      System.out.println(" &amp;#" + i + "; &lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/td&gt;");
    }
    System.out.println("&lt;/table&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt;");
  }
  
}

class AppTableAscii {
  public static void main(String[] args) {
     String arg = (args.length&gt;0) ? args[0] : "Decimal";
     try {
         Class c = Class.forName(arg);
         Representation repr = (Representation) c.newInstance();
         TableAsciiToHTML app = new TableAsciiToHTML(repr);
     }
     catch (ClassNotFoundException e) {
       System.out.println("Erreur : " + arg + " n'est pas une classe impl&eacute;ment&eacute;e.");
     }
     catch (InstantiationException e) {
       System.out.println("Erreur : " + arg + " n'est pas n'est pas du type attendu.");
     }
     catch (IllegalAccessException e) {
       System.out.println("Erreur : " + arg + " n'est pas accessible.");
     }
  }
}
      
      </pre></td></tr></table><p>
    </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1149"></a>4.2.&nbsp;Test</h3></div></div><div></div></div><p>Nous allons maintenant tester la qualit&eacute; <span class="foreignphrase"><i class="foreignphrase">Ouvert-Ferm&eacute;</i></span>, due au respect d'<span class="foreignphrase"><i class="foreignphrase">OCP</i></span> (POF Principe d'Ouverture/Fermeture).</p><p>Cr&eacute;ons une nouvelle classe d'impl&eacute;mentation de <span class="foreignphrase"><i class="foreignphrase">Representation</i></span>.</p><table border="0" bgcolor="#E0E0E0" width="100%"><tr><td><pre class="programlisting">
public class Hexadecimal implements Representation {
  public String toString(int n) {
    return Integer.toHexString(n);
  }
}
  </pre></td></tr></table><p>Apr&egrave;s compilation, nous ex&eacute;cutons le programme en lui passant en argument le nom de cette nouvelle classe. </p><table border="0" bgcolor="#E0E0E0" width="100%"><tr><td><pre class="programlisting">
  java AppTableAscii Hexadecimal &gt; res.html
</pre></td></tr></table><p>Le tour est jou&eacute;.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1173"></a>4.3.&nbsp;Conclusion</h3></div></div><div></div></div><p>Nous venons d'&eacute;tendre le comportement de l'application sans intervenir sur son code.</p><p>Nous avons pour cela respect&eacute; OCP (POF) et appliqu&eacute; DIP (PID).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="1" width="80%"><tr><td rowspan="2" align="center" valign="top" width="25"><img src="images/note.png"></td><td>Fichier de configuration XML</td></tr><tr><td colspan="1" align="left" valign="top"><p>Notez que la fonction d'instanciation "param&eacute;tr&eacute;e" est tr&egrave;s souvent d&eacute;l&eacute;gu&eacute;e &agrave; une classe sp&eacute;cialis&eacute;e (<span class="emphasis"><em>factory</em></span>). Celle-ci puise tr&egrave;s souvent les informations dont elle a besoin dans un (ou plusieurs) fichiers de configuration XML. Exemple (extrait d'un fichier de configuration d'une application Struts): </p><table border="0" bgcolor="#E0E0E0" width="100%"><tr><td><pre class="programlisting">

 &lt;form-beans&gt;
   &lt;form-bean
      name="addQuestionForm"
      type="org.reseaucerta.qcm.presentation.AddQuestionForm"/&gt;
      ...
 &lt;/form-beans&gt;

 &lt;!--  Action Mapping Definitions  --&gt;
 &lt;action-mappings&gt;
    &lt;action path="/addQuestion"
      type="org.reseaucerta.qcm.application.AddQuestionAction"
      name="addQuestionForm"
      scope="session"
      validate="true"
      input="/jsp/addQuestion.jsp"&gt;
      &lt;forward
         name="success"
         path="/jsp/confirmAddQuestion.jsp"/&gt;
      &lt;forward
         name="echec"
         path="/jsp/echecAddQuestion.jsp"/&gt;
    &lt;/action&gt;
    ... 
 &lt;action-mappings&gt;

</pre></td></tr></table></td></tr></table></div></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1190"></a>5.&nbsp;Initiation au design pattern Factory</h2></div></div><div></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1193"></a>5.1.&nbsp;Introduction</h3></div></div><div></div></div><p>Il existe une relation &eacute;troite entre les <span class="emphasis"><em>design patterns</em></span> (mod&egrave;les de conception) et les principes de conception objet.</p><p>Qu'est-ce qu'un <span class="emphasis"><em>design pattern</em></span> ? </p><p>Un design pattern est une <span class="emphasis"><em>description d'une solution logicielle r&eacute;utilisable face &agrave; un probl&egrave;me r&eacute;current en d&eacute;veloppement informatique.</em></span> (Mark Grand in <span class="emphasis"><em>Patterns in Java vol. 1</em></span>).</p><p>L'origine : les mod&egrave;les de construction architecturale par Christopher Alexander [1977].</p><p>Patterns logiciels : Kent Beck [1980] et Ward Cunningham [1987 et 1994].</p><p><span class="emphasis"><em>Typologie des Patterns</em></span></p><div class="itemizedlist"><ul type="disc"><li><p>Patterns d'analyse : m&eacute;thodes pour faire une bonne analyse (Fowler).</p></li><li><p>Patterns de conception : solutions standard de conception (gof). </p></li><li><p>Patterns d'impl&eacute;mentation : fa&ccedil;on de programmer un probl&egrave;me dans un langage particulier.</p></li></ul></div><p>Nous nous interessons aux patterns de conception (<span class="emphasis"><em>design patterns</em></span>).</p><p>Ouvrage de r&eacute;f&eacute;rence : </p><div class="itemizedlist"><ul type="disc"><li><p><span class="emphasis"><em>design patterns</em></span>  de Erich Gamma, Richard Heml, Ralph Johnson et John Vlissides. Ouvrage connu sous le nom de Gof (<span class="emphasis"><em>gang of four</em></span>) et disponible en fran&ccedil;ais aux &eacute;ditions Vuibert.</p></li></ul></div><p>Les design patterns offrent de nombreux avantages :</p><div class="itemizedlist"><ul type="disc"><li><p>Capturent l'exp&eacute;rience de d&eacute;veloppeurs, d'ing&eacute;nieurs, d'experts.</p></li><li><p>Permettent &agrave; n'importe quel d&eacute;veloppeur de r&eacute;utiliser un savoir-faire (ne pas r&eacute;inventer la roue).</p></li><li><p>Donnent un nom &agrave; des &eacute;l&eacute;ments d'architecture (enrichissement du vocabulaire pour une meilleure communication).</p></li></ul></div><p>Les design patterns sont rang&eacute;s dans des catalogues selon deux crit&egrave;res : le r&ocirc;le (cr&eacute;ateur, structurel, comportemantal) et le domaine (classe -statique- et objet -dynamique-) [Gof]. </p><div class="figure"><a name="d0e1262"></a><p class="title"><b>Figure&nbsp;22.&nbsp;Catalogue GOF</b></p><div><img src="espacePattern.png" alt="Catalogue GOF"></div></div><p>D'autres catalogues sont propos&eacute;s, notamment GRASP (<span class="emphasis"><em>General Responsability Assignement Software Patterns</em></span>), ou patterns g&eacute;n&eacute;raux d'affectation des responsabilit&eacute;s. Ces patterns d&eacute;crivent quelques principes fondamentaux en conception objet (Expert, Cr&eacute;ateur, Faible couplage, Forte coh&eacute;sion, Contr&ocirc;leur). </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1271"></a>5.2.&nbsp;Factory (Fabrique)</h3></div></div><div></div></div><p>Principe directement concern&eacute; : DIP</p><p>La mise en oeuvre du couplage abstrait, que pr&eacute;conise DIP, n&eacute;cessite toute fois un m&eacute;canisme d'instanciation afin de lier concr&egrave;tement les classes, &agrave; un moment donn&eacute;. C'est le r&ocirc;le des patterns cr&eacute;ateurs, en particulier ceux de type <span class="emphasis"><em>Factory</em></span>.</p><div class="figure"><a name="d0e1281"></a><p class="title"><b>Figure&nbsp;23.&nbsp;Pattern Factory </b></p><div><img src="factory.png" alt="Pattern Factory"></div></div><p>Les solutions les plus connues sont <span class="bold"><b>m&eacute;thode de fabrique</b></span> (<span class="emphasis"><em>method factory</em></span>) et <span class="emphasis"><em>fabrique abstraite</em></span> (<span class="emphasis"><em>abstract factory</em></span>).</p><p>La m&eacute;thode de fabrique se charge de construire une instance, par exemple en fonction d'un discriminant re&ccedil;u en argument.</p><p>La fabrique abstraite utilise l'h&eacute;ritage (et le polymorphisme) comme discriminant. Un syst&egrave;me tr&egrave;s souple qui permet &agrave; un client de choisir son fournisseur de classes concr&egrave;tes.</p><p>Exemple 1</p><table border="0" bgcolor="#E0E0E0" width="100%"><tr><td><pre class="programlisting">
class RepresentationFactory {
  static Representation getInstance(char typeRepr) {
     Representation repr;
     switch (typeRepr) {
          case 'd' :
             repr = new Decimal();
             break;
          case 'b' :
             repr = new Binaire();
             break;
           default :
             repr = new Decimal();
     }
     return repr;
  }  
}
</pre></td></tr></table><p>Exemple 2</p><table border="0" bgcolor="#E0E0E0" width="100%"><tr><td><pre class="programlisting">
interface RepresentationFactory {
  public Representation getInstance();
}

class ReprBinaire implements RepresentationFactory {
  public Representation getInstance(){
     return new Binaire();
  }   
}

class ReprDec implements RepresentationFactory {
  public Representation getInstance(){
     return new Decimal();
  }   
}
</pre></td></tr></table><div class="itemizedlist"><ul type="disc"><li><p><span class="emphasis"><em>Exercices</em></span></p><p>Appliquer le pattern Factory &agrave; l'exercice TableAscii-HTML. </p></li></ul></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1318"></a>5.3.&nbsp;Travaux pratiques</h3></div></div><div></div></div><p>Sujet d'apr&egrave;s un exemple pr&eacute;sent&eacute; par Tony Sintes sur JavaWorld.com (2002).</p><p>Consid&eacute;rons le besoin suivant : On souhaite offrir aux programmes &eacute;crits en java la possibilit&eacute; de &laquo;&nbsp;<span class="quote">tracer</span>&nbsp;&raquo; des mesages de debogage et d'erreur soit dans un fichier soit sur la console, et ceci de mani&egrave;re transparente.</p><p><span class="emphasis"><em>Listing 1</em></span></p><table border="0" bgcolor="#E0E0E0" width="100%"><tr><td><pre class="programlisting">
 public interface Trace {

       // placer le debogage &agrave; on ou off
       public void setDebug( boolean debug );

       // ecrire un message de debug
       public void debug( String message );

       // ecrire un message d'erreur
       public void error( String message );

 }
</pre></td></tr></table><p>
Supposons que nous ayons &eacute;crit deux implementations. Une impl&eacute;mentation (Listing 2) &eacute;crit les messages sur la console, tandis que l'autre (Listing 3) les &eacute;crit dans un fichier. 
</p><p><span class="emphasis"><em>Listing 2</em></span></p><table border="0" bgcolor="#E0E0E0" width="100%"><tr><td><pre class="programlisting">

 public class FileTrace implements Trace {
           
       private java.io.PrintWriter pw;
       private boolean debug;

       public FileTrace() throws java.io.IOException {
             // dans une version r&eacute;elle, FileTrace aurait besoin
             // d'obtenir d'une mani&egrave;re ou d'une autre le nom du fichier
             // pour cet exemple, il sera cod&eacute; en dur 
             pw = new java.io.PrintWriter( new java.io.FileWriter( "c:\trace.log" ) );
       }

       public void setDebug( boolean debug ) {
             this.debug = debug;
       }

       public void debug( String message ) {
             if( debug ) {  // imprimer seulement si debug est true
                   pw.println( "DEBUG: " + message );
                   pw.flush();
             }
       }
       public void error( String message ) {
             // toujours imprimer les erreurs
             pw.println( "ERREUR: " + message );
             pw.flush();
       }
 }
</pre></td></tr></table><p><span class="emphasis"><em>Listing 3</em></span></p><table border="0" bgcolor="#E0E0E0" width="100%"><tr><td><pre class="programlisting">
 public class SystemTrace implements Trace {

       private boolean debug;

       public void setDebug( boolean debug ) {
           this.debug = debug;
       }

       public void debug( String message ) {
           if( debug ) {  // imprimer uniquement si debug est true
                 System.out.println( "DEBUG: " + message );
           }
       }
       public void error( String message ) {
           System.out.println( "ERREUR: " + message );
       }
 }
</pre></td></tr></table><p>
Pour utiliser une de ces classes, nous nous y prendions comme cela : 
</p><p><span class="emphasis"><em>Listing 4</em></span></p><table border="0" bgcolor="#E0E0E0" width="100%"><tr><td><pre class="programlisting">

 class Test {
   public void run() {
     int x = 2;
     SystemTrace log = new SystemTrace();
     log.debug( "debut du log" );
     try {
       int x = 1/(x-2);
     }
     catch (Exception e) {
        log.error(e.getMessage());  
     }
     log.debug("Valeur de x : " + x);
   }  
   ...
 }
 </pre></td></tr></table><p>On souhaite pouvoir changer de politique de trace (console, fichier ou autres) sans toucher au code des applications utilisant les services de trace.</p><p>Proposez une solution.</p></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1357"></a>6.&nbsp;Exemple de solution</h2></div></div><div></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1360"></a>6.1.&nbsp;Introduction</h3></div></div><div></div></div><p>Nous devons d&eacute;coupler les programmes utilisateurs des fonctions de trace et les classes impl&eacute;mentant les services de Trace.</p><p>Nous respectons ainsi le principe ennonc&eacute; dans [Gof] : <span class="emphasis"><em>Programmer pour une interface et non pour une impl&eacute;mentation.</em></span></p><p><span class="emphasis"><em>Remarque : Dans la version fran&ccedil;aise de [Gof], le mot &laquo;&nbsp;<span class="quote">d&eacute;veloppement</span>&nbsp;&raquo; a &eacute;t&eacute; pr&eacute;f&eacute;r&eacute; (?) &agrave; &laquo;&nbsp;<span class="quote">implementation</span>&nbsp;&raquo;.</em></span></p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1378"></a>6.2.&nbsp;Listing 1</h3></div></div><div></div></div><p>Dans la version propos&eacute;e par l'auteur, les programmes clients d&eacute;l&egrave;guent enti&egrave;rement le choix de la classe d'impl&eacute;mentation de Trace &agrave; une Factory.</p><table border="0" bgcolor="#E0E0E0" width="100%"><tr><td><pre class="programlisting">
 //... some code ...
 Trace log = traceFactory.getTrace();
 //... code ...
 log.debug( "entering loog" );
 // ... etc ...
</pre></td></tr></table><p>Bien entendu, afin de gagner en souplesse, la <span class="emphasis"><em>factory</em></span> devra initialement &ecirc;tre obtenu au moyen du design pattern <span class="emphasis"><em>Abstract Factory</em></span> : </p><table border="0" bgcolor="#E0E0E0" width="100%"><tr><td><pre class="programlisting">
interface TraceFactory {
   public  Trace getTrace();
}
</pre></td></tr></table></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1395"></a>6.3.&nbsp;Listing 3</h3></div></div><div></div></div><p>Version initiale : les traces sont r&eacute;alis&eacute;es sur la console.</p><table border="0" bgcolor="#E0E0E0" width="100%"><tr><td><pre class="programlisting">
 public class TraceConsoleFactory implements TraceFactory {
       public Trace getTrace() {
             return new SystemTrace();
       }
 }
</pre></td></tr></table><p>Variante (<span class="emphasis"><em>sans intervenir sur les programmes client</em></span>) : les traces sont r&eacute;alis&eacute;es dans un fichier, toute fois, si cela s'av&egrave;re impossible, les traces se feront sur la console.</p><table border="0" bgcolor="#E0E0E0" width="100%"><tr><td><pre class="programlisting">
 public class TraceFileFactory implements TraceFactory {
    public Trace getTrace() {
      try {
         return new FileTrace();
      } catch ( java.io.IOException ex ) {
         Trace t = new SystemTrace();
         t.error( "could not instantiate FileTrace: " + ex.getMessage() );
         return t;
      }
   }
 }
</pre></td></tr></table><p>D&egrave;s lors nous pouvons imaginer une classe : </p><table border="0" bgcolor="#E0E0E0" width="100%"><tr><td><pre class="programlisting">
 public class AbstracTraceFactory {

    public static TraceFactory getTraceFactory()
    throws CreateTraceFactoryException {   
      try {
         // recherche dans un fichier de configuration
         // la factory &agrave; instancier 
         // ...
         // par exemple :
         return new FileTraceFactory();
         
      } catch ( Exception ex ) {
         throw new CreateTraceFactoryException(ex);
      }

   }

 }
</pre></td></tr></table></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1413"></a>7.&nbsp;Conclusion</h2></div></div><div></div></div><p>Nous venons de pr&eacute;senter le lien qu'il existe entre des principes de conception et programmation objet et les designs patterns sur un exemple mettant en oeuvre DIP (le principe) et Factory (le pattern). </p><p>Le domaine d'application et d'&eacute;tude des mod&egrave;les de conception est vaste, et en continuelle &eacute;volution.</p><p>N'h&eacute;sitez pas &agrave; investir ce sujet (livres et articles sur le web), et &agrave; faire un parall&egrave;le avec les principes objet sous-jacents. Vous trouverez dans le livre "Design patterns par la pratique" (en fran&ccedil;ais), des auteurs A.Shalloway et J.Trott, une pr&eacute;sentation et des exemples d'applications des mod&egrave;les de conception courants.</p></div></div></body></html>